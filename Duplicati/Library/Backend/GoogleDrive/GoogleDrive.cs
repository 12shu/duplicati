//  Copyright (C) 2015, The Duplicati Team
//  http://www.duplicati.com, info@duplicati.com
//
//  This library is free software; you can redistribute it and/or modify
//  it under the terms of the GNU Lesser General Public License as
//  published by the Free Software Foundation; either version 2.1 of the
//  License, or (at your option) any later version.
//
//  This library is distributed in the hope that it will be useful, but
//  WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
//  Lesser General Public License for more details.
//
//  You should have received a copy of the GNU Lesser General Public
//  License along with this library; if not, write to the Free Software
//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
using System;using System.Linq;using Duplicati.Library.Interface;using Duplicati.Library.Utility;using System.Collections.Generic;using Google.Apis.Drive.v2;using Google.Apis.Auth.OAuth2;using Google.Apis.Auth.OAuth2.Responses;using Google.Apis.Http;using System.Threading.Tasks;using System.Threading;using System.Net;using Google.Apis.Auth.OAuth2.Flows;using Google.Apis.Util;using Google.Apis.Drive.v2.Data;

namespace Duplicati.Library.Backend.GoogleDrive
{
    public class GoogleDrive : IBackend, IStreamingBackend, IQuotaEnabledBackend, IRenameEnabledBackend
    {        private const string AUTHID_OPTION = "authid";        private string m_path;        private OAuthHelper m_oauth;        private DriveService m_service;        private string m_currentFolderId;        private Dictionary<string, string> m_fileurls;        private Dictionary<string, string> m_fileids;        /// <summary>        /// Static initializer that loads a custom resolver        /// to fix issues with System.Net.HttpClient being        /// requested by the Google API in version 1.5.0.0,        /// but only having it available in v4.0.0.0 on Mono        /// </summary>        static GoogleDrive()        {            var httpasm = typeof(System.Net.Http.HttpClient).Assembly;            var httpver = new Version(1, 5, 0, 0);            AppDomain.CurrentDomain.AssemblyResolve += (s, a) => {                var requestedAssembly = new System.Reflection.AssemblyName(a.Name);                if (requestedAssembly.Name != "System.Net.Http" || requestedAssembly.Version != httpver)                    return null;                return httpasm;            };        }        public GoogleDrive()        {        }
        public GoogleDrive(string url, Dictionary<string, string> options)
        {
            var uri = new Utility.Uri(url);            m_path = uri.HostAndPath;            if (!m_path.EndsWith("/"))                m_path += "/";            string authid = null;            if (options.ContainsKey(AUTHID_OPTION))                authid = options[AUTHID_OPTION];            m_oauth = new OAuthHelper(authid, this.ProtocolKey);            m_fileurls = new Dictionary<string, string>();            m_fileids = new Dictionary<string, string>();        }        private DriveService Service        {            get            {                if (m_service == null)                {                    // Set up an empty token, as the API will renew it anyway                    // NOTE: These values are NOT used, as all info is stored                     // encrypted in the OAuth service, but we need to trick                    // the Google API to call the flow helper                    var token = new TokenResponse() {                         AccessToken = "Dummy",                        ExpiresInSeconds = 0,                        RefreshToken = "Dummy",                        TokenType = "Bearer"                     };                     m_service = new DriveService(new Google.Apis.Services.BaseClientService.Initializer() {                        ApplicationName = m_oauth.UserAgent,                        HttpClientInitializer = new UserCredential(new OAuthFlowHelper(m_oauth), null, token)                    });                }                return m_service;            }        }        private string GetFolderId(string path, bool autocreate = false)        {            var curparent = Service.About.Get().Execute().RootFolderId;            var curdisplay = "/";            var querytemplate = "title = '{0}' and mimeType = 'application/vnd.google-apps.folder' and '{1}' in parents";            foreach(var p in path.Split(new char[] {'/'}, StringSplitOptions.RemoveEmptyEntries))            {                var lst = Service.Files.List();                lst.Q = string.Format(querytemplate, EscapeTitleEntries(p), EscapeTitleEntries(curparent));                var res = lst.Execute();                if (res.Items.Count == 0)                {                    if (!autocreate)                        throw new FolderMissingException();                    curparent = Service.Files.Insert(new File() {                        Title = p,                        Description = p,                        MimeType = "application/vnd.google-apps.folder",                        Parents = new List<ParentReference>() { new ParentReference() { Id = curparent } }                    }).Execute().Id;                }                else if (res.Items.Count > 1)                    throw new Exception(Strings.GoogleDrive.MultipleEntries(p, curdisplay));                else                    curparent = res.Items[0].Id;                curdisplay += p + "/";            }            return curparent;        }        private string CurrentFolderId        {            get            {                if (string.IsNullOrEmpty(m_currentFolderId))                    m_currentFolderId = GetFolderId(m_path);                return m_currentFolderId;            }        }        private string GetFileInfo(string remotename, bool url, bool throwMissingException = true)        {            string entry;            if (url)                m_fileurls.TryGetValue(remotename, out entry);            else                m_fileids.TryGetValue(remotename, out entry);                        if (!string.IsNullOrEmpty(entry))                return entry;            var req = Service.Files.List();            req.Q = string.Format("title = '{0}' and mimeType != 'application/vnd.google-apps.folder' and '{1}' in parents", EscapeTitleEntries(remotename), EscapeTitleEntries(CurrentFolderId));            var list = req.Execute();            if (list.Items.Count == 0)            {                if (throwMissingException)                    throw new FileMissingException();                else                    return null;            }            else if (list.Items.Count > 1)                throw new Exception(string.Format(Strings.GoogleDrive.MultipleEntries(remotename, m_path)));                                m_fileurls[remotename] = list.Items[0].DownloadUrl;            m_fileids[remotename] = list.Items[0].Id;            if (url)                return list.Items[0].DownloadUrl;            else                return list.Items[0].Id;        }        private static string EscapeTitleEntries(string title)        {            return title.Replace("'", "\\'");        }        #region IStreamingBackend implementation        public void Put(string remotename, System.IO.Stream stream)        {            try            {                if (m_fileids == null)                    List();                string id;                m_fileids.TryGetValue(remotename, out id);                if (string.IsNullOrEmpty(id))                {                    var req = Service.Files.Insert(new File() {                        Title = remotename,                        Description = remotename,                        MimeType = "application/octet-stream",                        Parents = new List<ParentReference>() { new ParentReference() { Id = CurrentFolderId } }                    }, stream, "application/octet-stream");                    req.Upload();                    // Cache these for later use                    m_fileids[remotename] = req.ResponseBody.Id;                    m_fileurls[remotename] = req.ResponseBody.DownloadUrl;                }                else                {                    var req = Service.Files.Update(new File() {                        Title = remotename,                        Description = remotename,                        MimeType = "application/octet-stream",                        Parents = new List<ParentReference>() { new ParentReference() { Id = CurrentFolderId } }                    }, id, stream, "application/octet-stream");                    req.Upload();                    // Cache these for later use                    m_fileids[remotename] = req.ResponseBody.Id;                    m_fileurls[remotename] = req.ResponseBody.DownloadUrl;                }            }            catch            {                m_fileids.Clear();                m_fileurls.Clear();                throw;            }        }        public void Get(string remotename, System.IO.Stream stream)        {            // Prevent repeated download url lookups            if (m_fileurls.Count == 0)                List();                        using(var s = Service.HttpClient.GetStreamAsync(GetFileInfo(remotename, true)).Result)                Duplicati.Library.Utility.Utility.CopyStream(s, stream);        }        #endregion        #region IBackend implementation        public List<IFileEntry> List()        {            try            {                var res = new List<IFileEntry>();                m_fileurls.Clear();                m_fileids.Clear();                var req = Service.Files.List();                req.Q = string.Format("'{0}' in parents", EscapeTitleEntries(CurrentFolderId));                var list = req.Execute();                while(true)                {                    foreach(var n in list.Items)                    {                        FileEntry fe = null;                        if (n.FileSize == null)                            fe = new FileEntry(n.Title);                        else if (n.ModifiedDate == null)                            fe = new FileEntry(n.Title, n.FileSize.Value);                        else                            fe = new FileEntry(n.Title, n.FileSize.Value, n.ModifiedDate.Value, n.ModifiedDate.Value);                        if (fe != null)                        {                            fe.IsFolder = n.MimeType == "application/vnd.google-apps.folder";                            res.Add(fe);                            if (!fe.IsFolder)                            {                                m_fileurls[fe.Name] = n.DownloadUrl;                                m_fileids[fe.Name] = n.Id;                            }                        }                    }                    if (list.NextLink == null)                        break;                }                return res;            }            catch            {                m_fileurls.Clear();                m_fileids.Clear();                throw;            }        }        public void Put(string remotename, string filename)        {            using (System.IO.FileStream fs = System.IO.File.OpenRead(filename))                Put(remotename, fs);        }        public void Get(string remotename, string filename)        {            using (System.IO.FileStream fs = System.IO.File.Create(filename))                Get(remotename, fs);        }        public void Delete(string remotename)        {            try            {                // Prevent repeated fileid lookups                if (m_fileids.Count == 0)                    List();                                    Service.Files.Delete(GetFileInfo(remotename, false)).Execute();                m_fileids.Remove(remotename);                m_fileurls.Remove(remotename);            }            catch            {                m_fileids.Clear();                m_fileurls.Clear();                throw;            }        }        public void Test()        {            List();        }        public void CreateFolder()        {            m_fileids.Clear();            m_fileurls.Clear();            m_currentFolderId = GetFolderId(m_path, true);        }        public string DisplayName        {            get            {                return Strings.GoogleDrive.DisplayName;            }        }        public string ProtocolKey        {            get            {                return "googledrive";            }        }        public System.Collections.Generic.IList<ICommandLineArgument> SupportedCommands        {            get {                return new List<ICommandLineArgument>(new ICommandLineArgument[] {                    new CommandLineArgument(AUTHID_OPTION, CommandLineArgument.ArgumentType.Password, Strings.GoogleDrive.AuthidShort, Strings.GoogleDrive.AuthidLong(OAuthHelper.OAUTH_LOGIN_URL("googledrive"))),                });            }        }        public string Description        {            get            {                return Strings.GoogleDrive.Description;            }        }        #endregion        #region IQuotaEnabledBackend implementation        public long TotalQuotaSpace        {            get            {                try { return Service.About.Get().Execute().QuotaBytesTotal ?? -1; }                catch { }                return -1;            }        }        public long FreeQuotaSpace        {            get            {                try { return Service.About.Get().Execute().QuotaBytesUsed ?? -1; }                catch { }                return -1;            }        }        #endregion        #region IRenameEnabledBackend implementation        public void Rename(string oldname, string newname)        {            try            {                var id = GetFileInfo(oldname, false);                var req = Service.Files.Update(new File() {                    Title = newname,                    Description = newname,                    MimeType = "application/octet-stream",                    Parents = new List<ParentReference>() { new ParentReference() { Id = CurrentFolderId } }                }, id);                req.Execute();                m_fileurls[newname] = m_fileurls[oldname];                m_fileids[newname] = m_fileids[oldname];                m_fileurls.Remove(oldname);                m_fileids.Remove(oldname);            }            catch            {                m_fileids.Clear();                m_fileurls.Clear();                throw;            }        }        #endregion        #region IDisposable implementation        public void Dispose()        {        }        #endregion        private class OAuthFlowHelper : IAuthorizationCodeFlow        {            private OAuthHelper m_oauth;            public OAuthFlowHelper(OAuthHelper oauth)            {                m_oauth = oauth;                AccessMethod = new BearerToken.AuthorizationHeaderAccessMethod();            }            #region IAuthorizationCodeFlow implementation            public Task<TokenResponse> LoadTokenAsync(string userId, CancellationToken taskCancellationToken)            {                throw new NotImplementedException();            }            public Task DeleteTokenAsync(string userId, CancellationToken taskCancellationToken)            {                throw new NotImplementedException();            }            public Google.Apis.Auth.OAuth2.Requests.AuthorizationCodeRequestUrl CreateAuthorizationCodeRequest(string redirectUri)            {                throw new NotImplementedException();            }            public Task<TokenResponse> ExchangeCodeForTokenAsync(string userId, string code, string redirectUri, CancellationToken taskCancellationToken)            {                throw new NotImplementedException();            }            public Task<TokenResponse> RefreshTokenAsync(string userId, string refreshToken, CancellationToken taskCancellationToken)            {                return Task.Run<TokenResponse>(() => {                    var x = m_oauth.GetTokenResponse<TokenResponse>();                    return x;                });            }            public Task RevokeTokenAsync(string userId, string token, CancellationToken taskCancellationToken)            {                throw new NotImplementedException();            }            public IAccessMethod AccessMethod { get; private set; }            public Google.Apis.Util.IClock Clock { get { return SystemClock.Default; } }            public Google.Apis.Util.Store.IDataStore DataStore { get { return null; } }            #endregion            #region IDisposable implementation            public void Dispose()            {                            }            #endregion        }    }
}

